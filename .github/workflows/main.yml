name: Minecraft Server (Aternos Alternative)

on:
  workflow_dispatch:
    inputs:
      mc_version:
        description: 'Minecraft Version'
        default: '1.20.1'
        required: true
      mod_loader:
        description: 'Mod Loader'
        type: choice
        options:
        - vanilla
        - paper
        - fabric
        - forge
        default: forge
      java_distro:
        description: 'Java Distribution'
        type: choice
        options:
        - stock
        - graalvm
        default: stock
      java_version:
        description: 'Java Version (17 for 1.20.1, 21 for 1.20.5+)'
        default: '17'
        required: true
      # Server Properties
      motd:
        description: 'Server MOTD'
        default: 'A GitHub Actions Forge Server'
      difficulty:
        description: 'Difficulty'
        type: choice
        options: [peaceful, easy, normal, hard]
        default: normal
      hardcore:
        description: 'Hardcore Mode'
        type: boolean
        default: false
      online_mode:
        description: 'Online Mode (False = Cracked/Offline)'
        type: boolean
        default: true
      seed:
        description: 'Level Seed (Leave empty for random)'
        default: ''
      max_players:
        description: 'Max Players'
        default: '20'

jobs:
  play-minecraft:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to push changes and upload releases

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # --- Java Setup ---
      - name: Setup Stock Java
        if: ${{ inputs.java_distro == 'stock' }}
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ inputs.java_version }}

      - name: Setup GraalVM (SDKMAN)
        if: ${{ inputs.java_distro == 'graalvm' }}
        run: |
          curl -s "https://get.sdkman.io" | bash
          source "$HOME/.sdkman/bin/sdkman-init.sh"
          sdk install java ${{ inputs.java_version }}-graalce
          echo "JAVA_HOME=$JAVA_HOME" >> $GITHUB_ENV
          echo "$HOME/.sdkman/candidates/java/current/bin" >> $GITHUB_PATH

      # --- Preparation ---
      - name: Create Data Directory
        run: mkdir -p data

      - name: Restore World from Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking for previous backup..."
          gh release download backup -p "world.zip" -D data || echo "No backup found, starting fresh."
          cd data
          if [ -f world.zip ]; then
            unzip -o world.zip
            rm world.zip
            echo "World restored."
          fi

      # --- Download Server Jar (Logic for all loaders) ---
      - name: Download Server JAR
        working-directory: ./data
        run: |
          MC_VERSION="${{ inputs.mc_version }}"
          LOADER="${{ inputs.mod_loader }}"
          
          echo "Downloading $LOADER for Minecraft $MC_VERSION..."
          
          if [ "$LOADER" = "paper" ]; then
            BUILD=$(curl -s https://api.papermc.io/v2/projects/paper/versions/$MC_VERSION/builds | jq -r '.builds[-1].build')
            curl -o server.jar "https://api.papermc.io/v2/projects/paper/versions/$MC_VERSION/builds/$BUILD/downloads/paper-$MC_VERSION-$BUILD.jar"
          
          elif [ "$LOADER" = "fabric" ]; then
            curl -OJ "https://meta.fabricmc.net/v2/versions/loader/$MC_VERSION/stable/1.0.0/server/jar"
            mv fabric-server-mc*.jar server.jar
          
          elif [ "$LOADER" = "vanilla" ]; then
            MANIFEST_URL=$(curl -s https://launchermeta.mojang.com/mc/game/version_manifest.json | jq -r --arg V "$MC_VERSION" '.versions[] | select(.id == $V) | .url')
            DOWNLOAD_URL=$(curl -s $MANIFEST_URL | jq -r '.downloads.server.url')
            curl -o server.jar "$DOWNLOAD_URL"
            
          elif [ "$LOADER" = "forge" ]; then
            # Get the recommended Forge version for the selected Minecraft version
            PROMOS=$(curl -s "https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json")
            FORGE_VERSION=$(echo "$PROMOS" | jq -r ".promos[\"$MC_VERSION-latest\"]")
            if [ "$FORGE_VERSION" = "null" ]; then
              FORGE_VERSION=$(echo "$PROMOS" | jq -r ".promos[\"$MC_VERSION-recommended\"]")
            fi
            if [ "$FORGE_VERSION" = "null" ]; then
              echo "Error: Could not find a recommended or latest Forge version for Minecraft $MC_VERSION"
              exit 1
            fi
            
            echo "Found Forge version $FORGE_VERSION for Minecraft $MC_VERSION"
            INSTALLER_URL="https://maven.minecraftforge.net/net/minecraftforge/forge/$MC_VERSION-$FORGE_VERSION/forge-$MC_VERSION-$FORGE_VERSION-installer.jar"
            
            echo "Downloading installer from $INSTALLER_URL"
            curl -o forge-installer.jar "$INSTALLER_URL"
          fi

      # --- Install Forge Server (Only runs for Forge) ---
      - name: Install Forge Server
        if: ${{ inputs.mod_loader == 'forge' }}
        working-directory: ./data
        run: |
          echo "Running the Forge installer..."
          java -jar forge-installer.jar --installServer
          echo "Forge installation complete."

      # --- Configure Server ---
      - name: Configure Server Properties and EULA
        working-directory: ./data
        run: |
          echo "eula=true" > eula.txt
          
          cat <<EOF > server.properties
          #Generated by GitHub Actions
          accepts-transfers=false
          allow-flight=true
          difficulty=${{ inputs.difficulty }}
          enable-rcon=false
          gamemode=survival
          hardcore=${{ inputs.hardcore }}
          level-seed=${{ inputs.seed }}
          max-players=${{ inputs.max_players }}
          motd=${{ inputs.motd }}
          online-mode=${{ inputs.online_mode }}
          server-port=25565
          server-ip=0.0.0.0
          spawn-protection=0
          view-distance=10
          EOF

      # --- Networking (REQUIRED to join) ---
      - name: Setup Playit.gg Tunnel
        run: |
          curl -SsL https://playit-cloud.github.io/ppa/key.gpg | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/playit.gpg >/dev/null
          echo "deb [signed-by=/etc/apt/trusted.gpg.d/playit.gpg] https://playit-cloud.github.io/ppa/data ./" | sudo tee /etc/apt/sources.list.d/playit-cloud.list
          sudo apt-get update
          sudo apt-get install -y playit
          
          echo "Starting Playit.gg tunnel in the background..."
          nohup playit &
          sleep 5 # Give it a moment to initialize and print the address

      # --- Run Server ---
      - name: Start Minecraft Server
        working-directory: ./data
        run: |
          echo "-----------------------------------------------------"
          echo " STARTING SERVER - IT WILL RUN FOR A MAX OF 6 HOURS "
          echo " CHECK THE LOGS ABOVE FOR YOUR SERVER ADDRESS FROM PLAYIT.GG "
          echo "-----------------------------------------------------"
          
          if [ "${{ inputs.mod_loader }}" = "forge" ]; then
            # Forge generates a run.sh script which we must use
            chmod +x run.sh
            ./run.sh nogui
          else
            # Other server types use a standard server.jar
            java -Xms4G -Xmx6G -jar server.jar nogui
          fi

      # --- Backup Logic (Runs on stop/cancel/timeout) ---
      - name: Backup World to Release
        if: always() # This ensures the backup runs even if the workflow is cancelled
        working-directory: ./data
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Server stopped. Starting backup process..."
          
          # Only proceed if a world exists
          if [ ! -d "world" ]; then
            echo "No world directory found to back up."
            exit 0
          fi
          
          # 1. Zip the heavy world data
          echo "Zipping world files..."
          zip -r world.zip world world_nether world_the_end
          
          # 2. Upload World Zip to Release
          echo "Uploading backup to GitHub Releases..."
          gh release create backup --title "World Backup" --notes "Automated world backup" world.zip --target $GITHUB_SHA || \
          gh release upload backup world.zip --clobber
          
          # 3. Clean up heavy files before committing the rest
          rm -rf world.zip world world_nether world_the_end *.jar libraries versions logs cache config
          
          # 4. Commit smaller configs (whitelist, ops, etc.) to the repo
          cd ..
          git config --global user.name "GitHub Actions Backup"
          git config --global user.email "actions@github.com"
          git add data/
          git commit -m "Save non-world server data [skip ci]" || echo "No new config changes to commit."
          git push
